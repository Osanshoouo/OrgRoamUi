:PROPERTIES:
:NOTE_LEVEL: 2
:ID:       35230ea4-4c3a-46ba-8e55-484688702c48
:END:
#+title: Two's complement
#+filetags: :@computerEngineering:@boat:

Two's complement is the continuation of [[id:bb189bb3-4bdb-42b8-98c3-cd7f17fcc9d7][One's complement]]. The goal is to get rid of the need for the end-around carry and limit the complexity of overflow cases. Two's complement only works if the number of bits in the given calculation is fixed. Else you cant work with the Signbit.

Two's complement numbers, if they are negative, need to be turned into their positive countpart in order to easily decode the number into Decimal. If you tried to convert it the same way (2^0+2^1+...+2^n) then youd just get a wrong answer.

Just like in [[id:bb189bb3-4bdb-42b8-98c3-cd7f17fcc9d7][One's complement]], if you have subtraction, the instead you can do the following: Take the second value and do the following: Substract each digit from 1 to create a new value (inverting / flipping all the bits). Add 1 to that new value. 

For example: 108-90

90_10 = 01011010 (add 1 to every digit - creating the inverse)

10100101

now add 1 to it, giving you 10100110. Which is in turn -90.


|   01101100
| + 10100110
| = 00010010 

This can also ignore the carry. You just need to check if there was an overflow or not.


You can check if did the calculation right by just adding x and -x.

** Overflow rules for Two's Complement
:PROPERTIES:
:ID:       6a385b97-10e5-412e-8670-cb51ff1127f7
:END:
A Overflow happended if one of two cases happened in the result if:

1. The Signed Bit does not line up with the Operators
   1. *MSB being a 1* when adding two *positive* numbers
   2. *MSB being a 2* when adding two *negative* numbers
2. The Carry going into The MSB is not as the one going out

   If you are adding a negative and a posive number, then there can never be an overflow.
   
** Shortcut to take 2's complement value.

1. Starting at the LSB, copy all zeros up to and including the first 1.
2. Invert the remaining Digits
